[
["index.html", "htmlwidgets中文教程 声明", " htmlwidgets中文教程 徐静 译 2018-07-05 声明 htmlwidgets是R语言中非常有划时代意义的包，因为有了htmlwidgets使得R语言在交互可视化和基于JavaScript的编程有了实质性的进步。htmlwidgets目前没有中文说明文档和教程，该文档是对官方文档的详细翻译，译者水平有限，读者可以在https://github.com/DataXujing/htmlwidgets_CN/issues中留言指正。 "],
["e5ba8fe8a880.html", "序言", " 序言 htmlwidgets，一个用来创建HTML控件的包，可以运行在R命令行, R Markdown, Shiny。 Type Package Title HTML Widgets for R Version 1.2 Description A framework for creating HTML widgets that render in various contexts including the R console, &#39;R Markdown&#39; documents, and &#39;Shiny&#39; web applications. License MIT + file LICENSE VignetteBuilder knitr Imports grDevices, htmltools (&gt;= 0.3), jsonlite (&gt;= 0.9.16), yaml Suggests knitr (&gt;= 1.8) Enhances shiny (&gt;= 1.0.5) URL https://github.com/ramnathv/htmlwidgets BugReports https://github.com/ramnathv/htmlwidgets/issues RoxygenNote 6.0.1 NeedsCompilation no Author Ramnath Vaidyanathan [aut, cph],Yihui Xie [aut],JJ Allaire [aut, cre],Joe Cheng [aut], Kenton Russell [aut, cph],RStudio [cph] Maintainer JJ Allaire &lt;jj@rstudio.com&gt; Repository CRAN Date/Publication 2018-04-19 12:43:03 UTC 目前针对于htmlwidgets并没有详细的中文教程,译者会持续更新翻译htmlwidgets，并推出更多基于htmlwidgets的R包。 徐静 联信商务咨询有限公司 2017-06-02 "],
["e585b3e4ba8ee8af91e88085.html", "关于译者", " 关于译者 徐静： 硕士研究生, 目前的研究兴趣主要包括：数理统计，统计机器学习，深度学习，网络爬虫，前端可视化，R语言和Python语言的超级粉丝，多个R包和Python模块的作者，现在正逐步向Java迁移。 Graduate students,the current research interests include: mathematical statistics, statistical machine learning, deep learning, web crawler, front-end visualization. He is a super fan of R and Python, and the author of several R packages and Python modules, and now gradually migrating to Java. "],
["htmlwidgets-intro.html", "第 1 章 简介 1.1 概况 1.2 简单的开始 1.3 例子(sigma.js) 1.4 创建你自己的widgets", " 第 1 章 简介 1.1 概况 htmlwidgets包提供了一个R语言链接Javascript库的框架,HTML控件能够： 在R命令中做分析比如方便的R作图 和R Markdown结合在一起 和shiny结合在一起 保存为独立的网页，通过电子邮件，Dropbox等ad-oc共享。 通过遵循一小部分易于遵循的约定，可以创建非常小的代码和HTML控件，所有控件包含如下部分： Dependencies: 这些是控件用到的需要声明的Javascript和CSS R binding: 这是终端用户将调用的功能，以向控件提供输入数据，并制定控件应该如何呈现各种选项，这包括在shiny应用程序中使用控件所需要的一些简短的样板功能。 javaScript binding: 这是JavaScript代码，把所有的东西粘在一起。将R绑定中收集的数据和选项传递给底层的JavaScript库 已经有非常多的包基于htmlwidgets去完成,包括： leaflet – 交互的地图绘制包 dygraphs – 交互时间序列绘图包 networkD3 – 基于D3.js的交互网络图可视化 sparkline – 小型的内联图 DT – 表格可视化 rthreejs – 交互3D图 包的作者包括：Ramnath Vaidyanathan, Joe Cheng, JJ Allaire, Yihui Xie, and Kenton Russell等。 HTML控件一般会寄存在一个R包中，并且应该包含他们的依赖关系的所有源代码，例如这里译者写的以个基于htmlwidgets的R包:XuJIngd3plus。这是为了确保依赖的控件的完全可重复的(既不需要联网，也不需要运行服务器)，说白了在你R包中，应该包含所有的源码包括你底层调用的JavaScript包或CSS。 1.2 简单的开始 如果你懂R语言和一点JavaScript,创建自己的小控件非常简单，最先要做的就是要安装htmlwidgets,在CRAN上： install.packages(&#39;htmlwidgets&#39;) 你也可以在GitHub上安装开发版本： devtools::install_github(&#39;ramnathv/htmlwidgets&#39;) 通过包中自带的说明文档，让你快速的熟悉htmlwidgets并进入开发者状态,包括： Introduction to HTML Widgets HTML Widget Sizing HTML Widgets: Advanced Topics 我们会持续把他们翻译成中文,让中国人看起来更爽。 1.3 例子(sigma.js) 首先，我们将通过创建一个控件来封装sigma.js图形可视化库。当我们完成后，我们可以用来显示GEXF(Graph Exchange XML Format)数据文件的交互可视化，例如： library(sigma) data &lt;- system.file(&quot;examples/ediaspora.gexf.xml&quot;, package = &quot;sigma&quot;) sigma(data) 注意上面的输出仅仅是一个静态图像，你可以按照下文的Demo做一个交互的版本。 创建这种绑定所需的代码非常少。下面我们将一步一步地介绍所有的控件。然后，我们将描述如何创建自己的控件（包括为所有核心组件自动生成基本的脚手架）。 1.3.1 文件布局 假设我们的控件被命名为sigma,并且位于同名的R包中。我们的JavaScript绑定源代码文件名为sigma.js。由于我们的控件将读取GEXF数据文件，我们还需要包括基础sigma.min.js库以及GEXF插件，下面是我们将添加到包中的文件： R/ | sigma.R inst/ |-- htmlwidgets/ | |-- sigma.js | |-- sigma.yaml | |-- lib/ | | |-- sigma-1.0.3/ | | | |-- sigma.min.js | | | |-- plugins/ | | | | |-- sigma.parsers.gexf.min.js 请注意，JavaScript,YAML和其他依赖项都包含在inst/htmlwidgets目录中(随后将被安装到一个名为htmlwidgets的包的子目录中)。 1.3.2 依赖关系 依赖项是控件使用的JavaScript和CSS资源。依赖项包含在inst/htmlwidgets/lib目录中。依赖关系是使用YAML配置文件指定的，该文件使用控件的名称作为其基本文件名。以下是我们的sigma.yaml文件的样子 dependencies: - name: sigma version: 1.0.3 src: htmlwidgets/lib/sigma-1.0.3 script: - sigma.min.js - plugins/sigma.parsers.gexf.min.js 依赖关系src详述了引用目录，包含库和指定的JavaScript代码文件。如果包含多个JS脚本，每一个占每一行，并且以‘-开头。同时你可以天剑stylesheet条目，还有元条目或头条目，多依赖关系可以在一个YAML文件中声明，更多的请参考htmlDependency函数，该函数在htmltools包中 1.3.3 R绑定(R binding) 我们需要为用户提供一个调用我们的控件的R函数。通常，该函数将接受输入数据以及控制控件的显示的各种选项。下面是sigma的R函数： #&#39; @import htmlwidgets #&#39; @export sigma &lt;- function(gexf, drawEdges = TRUE, drawNodes = TRUE, width = NULL, height = NULL) { # read the gexf file data &lt;- paste(readLines(gexf), collapse=&quot;\\n&quot;) # create a list that contains the settings settings &lt;- list( drawEdges = drawEdges, drawNodes = drawNodes ) # pass the data and settings using &#39;x&#39; x &lt;- list( data = data, settings = settings ) # create the widget htmlwidgets::createWidget(&quot;sigma&quot;, x, width = width, height = height) } 函数包含两类输入：GEXF数据文件和一些附加的设置参数用来控制如何显示图片。这些输入都集中在一个叫做x的列表中，然后灌入到htmlwidgets::createWidget函数。这个x变量随后将被用于sigma的JavaScript绑定（下面将对此进行描述）,指定的任何宽度或高度参数也会被转发到widget（默认情况下，控件自动调整大小，因此通常不需要显式的宽度或高度）。 我们也希望sigma控件能够在shiny应用中使用，因此我们添加了下面的公式化的shiny output和render函数（对于所有的控件来说，它总是相同的） #&#39; @export sigmaOutput &lt;- function(outputId, width = &quot;100%&quot;, height = &quot;400px&quot;) { htmlwidgets::shinyWidgetOutput(outputId, &quot;sigma&quot;, width, height, package = &quot;sigma&quot;) } #&#39; @export #https://blog.csdn.net/songzhilian22/article/details/49487467 renderSigma &lt;- function(expr, env = parent.frame(), quoted = FALSE) { if (!quoted) { expr &lt;- substitute(expr) } # force quoted htmlwidgets::shinyRenderWidget(expr, sigmaOutput, env, quoted = TRUE) } 1.3.4 JavaScript绑定(JavaScript binding) 注意：在htmlwidgets0.5.2和更早的版本中使用了一个更老、更不直观的JavaScript绑定API，并在htmlwidgets的更新版本中继续支持。有关遗留绑定API的详细信息，请参见此归档版本。新的控件件被鼓励使用下面描述的更新的API。谜题中的第三个部分是激活控件所需的JavaScript。按照惯例，我们将在文件inst/htmlwidgets/sigma.js中定义JavaScript绑定。下面是绑定的完整源代码： HTMLWidgets.widget({ name: &quot;sigma&quot;, type: &quot;output&quot;, factory: function(el, width, height) { // create our sigma object and bind it to the element var sig = new sigma(el.id); return { renderValue: function(x) { // parse gexf data var parser = new DOMParser(); var data = parser.parseFromString(x.data, &quot;application/xml&quot;); // apply settings for (var name in x.settings) sig.settings(name, x.settings[name]); // update the sigma object sigma.parsers.gexf( data, // parsed gexf data sig, // sigma object function() { // need to call refresh to reflect new settings and data sig.refresh(); } ); }, resize: function(width, height) { // forward resize on to sigma renderers for (var name in sig.renderers) sig.renderers[name].resize(width, height); }, // Make the sigma object available as a property on the widget // instance we&#39;re returning from factory(). This is generally a // good idea for extensibility--it helps users of this widget // interact directly with sigma, if needed. s: sig }; } }); 我们为控件提供了名称和类型，再加上一个工厂函数，它采用el（将承载这控件的HTML元素）、宽度和高度（HTML元素的宽度和高度，以像素为单位），您总是可以使用OffStStand宽度和OffSETHEE来实现这一点。 工厂函数要准备启动接收HTML元素的值。在这个案例，我们创建一个新的sigma元素和把它的DOM元素的ID，承载页面的控件。 我们稍后需要访问sigma对象（以更新它的数据和设置），因此我们将其保存为变量sig。请注意，直接在工厂函数内部声明的变量与特定的控件实例/el绑定。 工厂函数的返回值被称为控件实例对象。它是htmlwidgets运行时和正在包装的JavaScript可视化之间的桥梁。顾名思义，每个控件实例对象负责管理页面上的单个控件实例。 您创建的控件实例对象必须有一个所需的方法，并且可以有一个可选的方法： 所需的renderValue方法实际上将动态数据和设置填充到WEB的DOM元素中。x包含控件数据和设置。我们解析和更新GEXF数据，将设置应用到我们先前创建的sig Sigma对象，最后调用刷新以反映屏幕上的新值。这种方法可以重复调用不同的数据（例如：在shiny中），所以一定要考虑到这种可能性。如果它对你的控件有意义， 考虑使您的可视化转换顺利地从x的一个值开始到另一个。 每当包含控件的元素被调整大小时，就会调用可选的大小调整方法。不执行此方法的唯一原因是如果您的控件自然缩放（当它的元素大小改变时不需要附加的JavaScript代码）。在sigma .js的情况下，我们将大小调整信息转发给每个底层sigma渲染器。 所有JavaScript库都处理初始化、绑定到DOM元素、动态更新数据和稍微不同地调整大小。创建控件的JavaScript方面的大部分工作是将这三个函数工厂、渲染值和大小正确地映射到底层库的行为。sigma.js示例使用一个简单的对象文字来创建它的控件实例对象，但是您也可以使用基于类的对象或任何其他样式的对象，只要obj.renderValue(x)和obj.resize(width, height)（宽度，高度）可以调用它。 可以在控件实例对象上添加其他方法和属性。虽然它们不会被htmlwidgets本身调用，但它们可能对知道一些JavaScript的控件的用户有用，并希望通过添加自定义JS代码（例如使用htmlwidgets::onRender R函数）来进一步定制您的控件。在这种情况下，我们添加一个s属性，使sigma对象本身可用。 1.3.5 演示 我们的控件现在完成了！如果您想在不重放所有代码的情况下测试它，您可以从GitHub安装它如下： devtools::install_github(&#39;jjallaire/sigma&#39;) 下面是代码的示例，其中包含了包中包含的一些示例数据： library(sigma) sigma(system.file(&quot;examples/ediaspora.gexf.xml&quot;, package = &quot;sigma&quot;)) 如果在R控制台中执行此代码，您将看到在RStudio Viewer中显示的控件（或者如果不运行RStudio，则在外部浏览器中）。如果将其包含在R Markdown文档中，则窗口控件将嵌入到文档中。 我们还可以在shiny应用程序中使用控件： library(shiny) library(sigma) gexf &lt;- system.file(&quot;examples/ediaspora.gexf.xml&quot;, package = &quot;sigma&quot;) ui = shinyUI(fluidPage( checkboxInput(&quot;drawEdges&quot;, &quot;Draw Edges&quot;, value = TRUE), checkboxInput(&quot;drawNodes&quot;, &quot;Draw Nodes&quot;, value = TRUE), sigmaOutput(&#39;sigma&#39;) )) server = function(input, output) { output$sigma &lt;- renderSigma( sigma(gexf, drawEdges = input$drawEdges, drawNodes = input$drawNodes) ) } shinyApp(ui = ui, server = server) 1.4 创建你自己的widgets 1.4.1 需求（Requirements） 要实现一个控件，您需要创建一个新的R包，而这又取决于htmlwidgets包。可以在CRAN中安装： install.packages(&quot;htmlwidgets&quot;) 1.4.2 脚手架（Scaffolding） 要创建一个新的控件，可以调用scaffoldWidget函数来生成控件的基本结构。函数将： 创建.R,.js,.yaml等控件需要的文件 如果提供，取一个Bower包名称并自动下载JavaScript库（及其依赖项），并将所需的条目添加到.yaml文件中。 这个方法是非常推荐的，因为它确保你开始使用正确的文件结构。 下面是一个示例，假设您希望在一个新的同名包中创建名为“mywidget”的小部件： devtools::create(&quot;mywidget&quot;) # create package using devtools setwd(&quot;mywidget&quot;) # navigate to package dir htmlwidgets::scaffoldWidget(&quot;mywidget&quot;) # create widget scaffolding devtools::install() 这将创建一个简单的控件，它使用单个文本参数，并在控件HTML元素中显示该文本。你可以这样试试： library(mywidget) mywidget(&quot;hello, world&quot;) 这是最可能的控件，并且还没有包含一个JavaScript库来连接（注意，scaffoldWidget可以可选地包含通过JavaScript库依赖关系的bowerPkg参数）这是最可能的小部件，并且还没有包含一个JavaScript库来连接（注意，scaffoldWidget可以可选地包含通过JavaScript库依赖关系的bowerPkg参数）。 在开始开发之前，您应该查看上面的介绍性示例，以确保您理解各个组件，并在下一节中查看与文章相关联的附加文章和示例。 1.4.3 更多 1.4.3.1 其他 还有更多的文章覆盖更高级的领域： HTML Widget Sizing：解释自定义大小调整策略以及何时可能需要使用它们，并描述在JavaScript绑定中实现调整大小的方法。 HTML Widgets: Advanced Topics：描述支持每个控件实例数据、数据转换（例如，将数据帧转换为D3数据集）以及提供live JavaScript对象（例如函数定义）的控件选项的框架特征。 当大多数JavaScript库需要一些额外的交互以保持它们的大小与它们的包含元素同步时，HTML Widget Sizing就显得尤为重要。 1.4.3.2 例子 学习其他包的代码是了解更多关于创建小部件的一个好方法： networkD3 dygraphs sparkline 1.4.3.3 问题 如果您对开发控件或开发过程中遇到的问题有疑问，请毫不犹豫地在项目的GitHub存储库上发布一个问题。 "],
["htmlwidgets-Sizing.html", "第 2 章 HTML空间尺寸调整 2.1 概述 2.2 指定大小调整策略 2.3 JavaScript调整大小方法", " 第 2 章 HTML空间尺寸调整 2.1 概述 在HTML控件的工作中，就像R中的绘图(plot)，HTML控件智能的将他们自己的大小放在容器中，无论是在Rstudio Viewer中，knitr中的图还是在Shiny UI中的面板。htmlwidgets框架提供了一种丰富的机制来指定控件的大小调整行为。 这种大小调整机制是为了解决影响控件的自然尺寸的以下约束： The kind of widget it is.有些控件可能仅仅需要设计成小的，固定尺寸(例如sparkline),而有些控件可能需要基于像素点做不断地调整(例如network graphs) The context into which the widget is rendered.有些控件在R Markdown中看起来是以 \\(980px \\times 480px\\),相同的控件在Rstudio的Viewer中看起来要小的多。 分两步处理控件的大小： 首先为控件指定大小调整策略，这是通过createWidget函数中的sizingPolicy参数实现的。大多数控件可以接受默认的大小调整策略((或者只覆盖其中的一个或两个方面）并获得满意的大小调整行为（详见下文）。) 框架使用大小调整策略来计算给定的窗口中所呈现的窗口的正确宽度和高度。然后将其大小信息传递给控件JavaScript绑定的初始化和调整大小方法。控件将大小的信息传递给底层的JS库。 2.2 指定大小调整策略 默认HTML窗口大小调整策略使用与R图相同大小的语义来处理控件。当在R控制台上打印时，窗口小部件显示在RStudio Viewer中，并且大小以填充查看器窗格（模数任何填充）。当在R Markdown文档中呈现时，控件大小基于默认的图片文件的大小。 需要注意的是对于大多数的控件来说默认的大小是很不错的选择，你不需要去创建一个大小调整的策略。如果你想轻微的修改大小策略，使得与默认的不同，那么你可以调用sizingPolicy函数，然后把结果传递给createWidget函数。例如： htmlwidgets::createWidget( &quot;sigma&quot;, x, width = width, height = height, sizingPolicy = htmlwidgets::sizingPolicy( viewer.padding = 0, viewer.paneHeight = 500, browser.fill = TRUE ) ) 2.2.1 例子 networkD3包对所有的控件直接使用了自定义的大小策略，simpleNetwork控件消除填充（因为D3已经提供填充），并且指定当它在一个独立的Web浏览器中显示时，它希望填充尽可能多的空间： sizingPolicy(padding = 0, browser.fill = TRUE) sankeyNetwork控件需要比Rstudio Viewer提供的更多的空间或典型的knitr图片，因此它禁用了那些自动调整大小的行为。针对于knitr文档他还提供了一个恰当的默认的宽和高： sizingPolicy(viewer.suppress = TRUE, knitr.figure = FALSE, browser.fill = TRUE, browser.padding = 75, knitr.defaultWidth = 800, knitr.defaultHeight = 500) 2.2.2 可用选项 以下是在大小调整策略中可以指定的各种选项： Option Description defaultWidth The default width used to display the widget. This parameter specifies the default width for viewing in all contexts (browser, viewer, and knitr) unless it is specifically overridden with e.g. browser.defaultWidth. defaultHeight The default height used to display the widget. This parameter specifies the default height for viewing in all contexts (browser, viewer, and knitr) unless it is specifically overridden with e.g. browser.defaultHeight. padding Padding around the widget (in pixels). This parameter specifies the padding for viewing in all contexts (browser and viewer) unless it is specifically overridden by e.g. browser.padding. viewer.defaultWidth The default width used to display the widget within the RStudio Viewer. viewer.defaultHeight The default height used to display the widget within the RStudio Viewer. viewer.padding Padding around the widget when displayed in the RStudio Viewer (defaults to 15 pixels). viewer.fill When displayed in the RStudio Viewer, automatically size the widget to the viewer dimensions (note that viewer.padding is still applied). Default to TRUE. viewer.suppress Never display the widget within the RStudio Viewer (useful for widgets that require a large amount of space for rendering). Defaults to FALSE. viewer.paneHeight Request that the RStudio Viewer be forced to a specific height when displaying this widget. browser.defaultWidth The default width used to display the widget within a standalone web browser. browser.defaultHeight The default height used to display the widget within a standalone web browser browser.padding Padding around the widget when displayed in a standalone browser (defaults to 40 pixels). browser.fill When displayed in a standalone web browser, automatically size the widget to the browser dimensions (note that browser.padding is still applied). Defaults to FALSE. browser.external When displaying in a browser, always use an external browser (via browseURL()). Defaults to FALSE, which will result in the use of an internal browser within RStudio v1.1 and higher. knitr.defaultWidth The default width used to display the widget within documents generated by knitr (e.g. R Markdown). knitr.defaultHeight The default height used to display the widget within documents generated by knitr (e.g. R Markdown). knitr.figure Apply the default knitr fig.width and fig.height to the widget when it’s rendered within R Markdown documents. Defaults to TRUE. 2.3 JavaScript调整大小方法 设置大小策略允许htmlwidgets在展示图像的区域计算控件的宽和高，然而你仍然需要把你定义的这种大小信息传递给底层你创建控件所使用的JavaScript库。 每一个JavaSript库在处理动态大小调整问题时都有一些不同，有些可能自动调整，有些可能需要通过resize()函数调用布局，有些可能需要通过设置数据或其他选项实现。无论哪种情况，htmlwidhets框架将把计算的大小传递给函数factory和resize函数.下面是一个空的JavaScript binding的说明例子： HTMLWidgets.widget({ name: &quot;demo&quot;, type: &quot;output&quot;, factory: function(el, width, height) { return { renderValue: function(x) { }, resize: function(width, height) { } }; } }); 您所处理的宽度和高度是由您决定的，它取决于您正在创建控件的基础JavaScript库的大小调整语义。 2.3.1 例子 2.3.1.1 dygraphs 在dygraphs控件中，调整大小的实现现对简单，因为dygraphs库包含一个resize()方法来自动的将该图大小映射到封闭HTML元素。 resize: function(width, height) { if (dygraph) dygraph.resize(); } 2.3.1.2 forceNetwork 在forceNetwork通过适用于承载D3网络可视化的&lt;svg&gt;标签来传递宽和高的大小变化。 factory: function(el, width, height) { // instance data var el = el; var force = d3.layout.force(); d3.select(el).append(&quot;svg&quot;) .attr(&quot;width&quot;, width) .attr(&quot;height&quot;, height); return { renderValue: function(x) { // implementation excluded }, resize: function(width, height) { d3.select(el).select(&quot;svg&quot;) .attr(&quot;width&quot;, width) .attr(&quot;height&quot;, height); force.size([width, height]).resume(); } }; } 我们看到在不同的JavaScript库中，resize方法可能会提供灵活的自动调整大小的逻辑，这是我们需要注意的。 "],
["htmlwidgets-advanced.html", "第 3 章 HTML控件：高级主题 3.1 本节概述 3.2 数据变换 3.3 传递JavaScript函数 3.4 自定义控件HTML", " 第 3 章 HTML控件：高级主题 3.1 本节概述 本部分将介绍创建控件的几个主要方面，这些控件并不是所有控件都需要的，但他是获得绑定到某些类型的JavaScript库才能正常工作的重要部分。涵盖的主题包括： 将R对象的JSON表示转换为JavaScript库所需的表示（例如，R数据帧到D3数据集）。 在JavaScript绑定中跟踪特定于实例的控件数据。 将JavaScript函数从R传递到JavaScript（例如用户提供的格式化或绘图功能）。 生成自定义HTML以封装控件（默认为&lt;div &gt;但一些库需要不同的元素，例如&lt;SPAN &gt;） 3.2 数据变换 R对象传递一个参数x给createWidget()函数，并使用内部函数htmlwidgets:::toJSON()转换成JSON字符串，默认情况下，它基本上是jsonlite::toJSON()的包装函数。但是，有时这种表示并不是您所连接的JavaScript库所要求的。有两个JavaScript函数可以用来转换JSON数据。 3.2.1 HTMLWidgets.dataframeToD3() R数据框是’long form’(长型数据:数组名加一个向量)然而d3需要一个’wide form’(宽型数据:每一行都有以键值对形式表示)，在R中使用dataframeToD3()函数就可以把数据变化成JavaScript对用格式的数据 用一个例子来说明R的long-form数据 { &quot;Sepal.Length&quot;: [5.1, 4.9, 4.7], &quot;Sepal.Width&quot;: [3.5, 3, 3.2], &quot;Petal.Length&quot;: [1.4, 1.4, 1.3], &quot;Petal.Width&quot;: [0.2, 0.2, 0.2], &quot;Species&quot;: [&quot;setosa&quot;, &quot;setosa&quot;, &quot;setosa&quot;] } 使用HTMLWidgets.dataframeToD3()，将会变成： [ { &quot;Sepal.Length&quot;: 5.1, &quot;Sepal.Width&quot;: 3.5, &quot;Petal.Length&quot;: 1.4, &quot;Petal.Width&quot;: 0.2, &quot;Species&quot;: &quot;setosa&quot; }, { &quot;Sepal.Length&quot;: 4.9, &quot;Sepal.Width&quot;: 3, &quot;Petal.Length&quot;: 1.4, &quot;Petal.Width&quot;: 0.2, &quot;Species&quot;: &quot;setosa&quot; }, { &quot;Sepal.Length&quot;: 4.7, &quot;Sepal.Width&quot;: 3.2, &quot;Petal.Length&quot;: 1.3, &quot;Petal.Width&quot;: 0.2, &quot;Species&quot;: &quot;setosa&quot; } ] 作为一个实际例子，simpleNetwork接受包含R侧的网络链接的数据框，然后将其转换为JavaScript renderValue函数内的D3表示： renderValue: function(x) { // convert links data frame to d3 friendly format var links = HTMLWidgets.dataframeToD3(x.links); // ... use the links, etc ... } 3.2.2 HTMLWidgets.transposeArray2D() 有时二维数组需要类似的换位。为此，提供了transposeArray2D()函数。下面是一个示例数组： [ [5.1, 4.9, 4.7, 4.6, 5, 5.4, 4.6, 5], [3.5, 3, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4], [1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5], [0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2], [&quot;setosa&quot;, &quot;setosa&quot;, &quot;setosa&quot;, &quot;setosa&quot;, &quot;setosa&quot;, &quot;setosa&quot;, &quot;setosa&quot;, &quot;setosa&quot;] ] HTMLWidgets.transposeArray2D()把其变换成： [ [5.1, 3.5, 1.4, 0.2, &quot;setosa&quot;], [4.9, 3, 1.4, 0.2, &quot;setosa&quot;], [4.7, 3.2, 1.3, 0.2, &quot;setosa&quot;], [4.6, 3.1, 1.5, 0.2, &quot;setosa&quot;], [5, 3.6, 1.4, 0.2, &quot;setosa&quot;], [5.4, 3.9, 1.7, 0.4, &quot;setosa&quot;], [4.6, 3.4, 1.4, 0.3, &quot;setosa&quot;], [5, 3.4, 1.5, 0.2, &quot;setosa&quot;] ] dygraphs控件就使用了这种变换： renderValue: function(x) { // ... code excluded ... // transpose array x.attrs.file = HTMLWidgets.transposeArray2D(x.attrs.file); // ... more code excluded ... } 3.2.3 自定义JSON串行化器 当htmlwidgets中的默认JSON序列化器无法按您预期的方式工作时，您可能会发现需要自定义控件数据的JSON序列化。对于实现控件的包的作者，JSON序列化有两个定制级别：您可以自定义jsonlite::toJSON()的参数的默认值，或者只需定制整个函数。 jsonlite::toJSON()有很多参数，并且我们已经改变了它的很多默认值。下面是我们在htmlwidgets中使用的JSON序列化器： function (x, ..., dataframe = &quot;columns&quot;, null = &quot;null&quot;, na = &quot;null&quot;, auto_unbox = TRUE, digits = getOption(&quot;shiny.json.digits&quot;, 16), use_signif = TRUE, force = TRUE, POSIXt = &quot;ISO8601&quot;, UTC = TRUE, rownames = FALSE, keep_vec_names = TRUE, strict_atomic = TRUE) { if (strict_atomic) x &lt;- I(x) jsonlite::toJSON(x, dataframe = dataframe, null = null, na = na, auto_unbox = auto_unbox, digits = digits, use_signif = use_signif, force = force, POSIXt = POSIXt, UTC = UTC, rownames = rownames, keep_vec_names = keep_vec_names, json_verbatim = TRUE, ...) } 例如，我们通过列而非行将数据框转化为JSON(后者是jsonlite::toJSON的默认设置)，如果要更改任何参数的默认值，可以将属性TOJSON ARGS附加到将被传递给createWidgets()的widgets数据。例如： fooWidget &lt;- function(data, name, ...) { # ... process the data ... params &lt;- list(foo = data, bar = TRUE) # customize toJSON() argument values attr(params, &#39;TOJSON_ARGS&#39;) &lt;- list(digits = 7, na = &#39;string&#39;) htmlwidgets::createWidget(name, x = params, ...) } 在上面的例子中，我们将数字的默认值从16改为7，NA从NULL改为String.您是否需要向用户公开这样的定制，这取决于包的作者。例如，您可以在控件中附加一个参数，这样用户就可以自定义JSON序列化程序的行为： fooWidget &lt;- function(data, name, ..., JSONArgs = list(digits = 7)) { # ... process the data ... params &lt;- list(foo = data, bar = TRUE) # customize toJSON() argument values attr(params, &#39;TOJSON_ARGS&#39;) &lt;- JSONArgs htmlwidgets::createWidget(name, x = params, ...) } 还可以使用全局选项htmlwidgets.TOJSON_ARGS为当前会话中的所有控件自定义JSON序列化参数，例如： options(htmlwidgets.TOJSON_ARGS = list(digits = 7, pretty = TRUE)) 如果不想使用jsonlite,可以通过将属性TOJSON_FUNC附加到widget数据，完全重写序列化函数，例如： fooWidget &lt;- function(data, name, ...) { # ... process the data ... params &lt;- list(foo = data, bar = TRUE) # customize the JSON serializer attr(params, &#39;TOJSON_FUNC&#39;) &lt;- MY_OWN_JSON_FUNCTION htmlwidgets::createWidget(name, x = params, ...) } 这里MY_OWN_JSON_FUNCTION函数可以是一个将R对象转换为JSON的任意R函数。如果您还指定了TOJSON_ARGS属性，它也将传递给您的自定义JSON函数。注意这些自定义JSON序列化程序的特性要求在Shiny的应用程序中呈现控件时，Shiny的版本大于0.111。 3.3 传递JavaScript函数 正如您所期望的，从R传递到JavaScript的字符向量被转换成JavaScript字符串。但是，如果您希望允许用户提供自定义的JavaScript函数用于格式化、绘图或事件处理，该怎么办？对于这种情况，htmlwidgets包包含一个JS()函数，它允许您在客户端接收到一个字符值时将其作为JavaScript进行评估。 例如，dygraphs控件包括允许用户为各种上下文提供回调函数的dyCallbacks函数。这些回调被标记为包含JavaScript，以便它们可以在客户端上转换成实际的JavaScript函数： callbacks &lt;- list( clickCallback = JS(clickCallback) drawCallback = JS(drawCallback) highlightCallback = JS(highlightCallback) pointClickCallback = JS(pointClickCallback) underlayCallback = JS(underlayCallback) ) 另一个例子是DT包控件，用户可以在加载和初始化表之后制定一个带有JavaScript的intCallback来执行。 datatable(head(iris, 20), options = list( initComplete = JS( &quot;function(settings, json) {&quot;, &quot;$(this.api().table().header()).css({&#39;background-color&#39;: &#39;#000&#39;, &#39;color&#39;: &#39;#fff&#39;});&quot;, &quot;}&quot;) )) 如果将多个参数传递给JS(),（例如上面的示例中），它们将被级联成由\\n分隔的单个字符串。 3.4 自定义控件HTML 通常，控件的HTML“外壳”只是一个&lt;div&gt;元素，而这是对应于新的控件的默认行为，而这些控件不是以其他方式指定的。然而有时你需要不同的标签类型，例如sparkline控件中需要&lt;span&gt;，因此实现以下自定义HTML生成函数： sparkline_html &lt;- function(id, style, class, ...){ tags$span(id = id, class = class) } 请注意，这个函数是在由widgetname_html实现的小程序包中查找的，因此它不必从包中正式导出或以其他方式注册到htmlwidgets。 大多数的控件都不需要自定义HTML函数，但是如果需要为你的控件生成自定义的HTML（例如你需要一个&lt;input&gt;或&lt;span&gt;而不是一个&lt;div&gt;),那么你应该是用htmltools包。 "],
["htmlwidgets-pkgintro.html", "第 4 章 htmlwidgets包中函数的总结 4.1 htmlwidgets包函数", " 第 4 章 htmlwidgets包中函数的总结 一个完整的R包提交到CRAN,都会有一个函数使用的说明文档或手册，htmlwidgets也不例外,我们将按照原说明文档的函数顺序，翻译解释htmlwidgets包中函数的用途和参数设置。这其中有些方法我们在前三章中已经提到。 4.1 htmlwidgets包函数 4.1.1 htmlwidgets-package 使用R创建HTML控件的包的信息 描述 htmlwidgets包提供了一个简单的创建R链接JavaScript包的框架，使用该框架创建控件可以： 在R控制台上使用JavaScript可视化库，就像绘图一样 在R Markdown文档和Shiny Web应用程序中嵌入控件 对保存网页，共享分析成果 在R中可以参考下面文档(这些说明文档译者已经在前三章翻译) vignette(&quot;develop_intro&quot;, package = &quot;htmlwidgets&quot;) #第一章 vignette(&quot;develop_sizing&quot;, package = &quot;htmlwidgets&quot;) #第二章 vignette(&quot;develop_advanced&quot;, package = &quot;htmlwidgets&quot;) #第三章 包的源码地址：https://github.com/ramnathv/htmlwidgets 作者 Ramnath Vaidyanathan, Joe Cheng, JJ Allaire, and Yihui Xie 4.1.2 createWidget 创建HTML控件函数 描述 基于控件的YAML文件和给定的JavaScript库创建一个HTML控件。 用法 createWidget(name, x, width = NULL, height = NULL, sizingPolicy = htmlwidgets::sizingPolicy(), package = name, dependencies = NULL, elementId = NULL, preRenderHook = NULL) 参数 name: 控件名称(要和YAML和JS文档中的名称保持一致) x: 传入控件的数据，要转化为JSON格式的数据。 width: 控件的宽度，默认值是NULL,默认会自适应调整宽度 height: 控件的高度，默认值是NULL,默认会自适应调整高度 sizingPoicy: 调整控件大小的策略，详见第二章 package: 定义控件所在的包（默认就是控件的名称） dependencies: 控件额外的依赖(YAML文件定义之外)，特别是对于一些动态的依赖选项是有必要的 elementID: 使用控件的显示元素ID(而不是自动生成的元素ID) ,如果您有JavaScript与特定的实例控件交互这是很有必要的 preRenderHook: 一个运行在控件上的函数。 细节 更多细节可以参考第一章 值 htmlwidgets对象,这将在不同的上下文中智能地将自己打印到HTML中。 包括R控制台，在R Markdown文档中，以及在Shiny的输出绑定中。 4.1.3 getDependency 获取htmlwidgets的JS和CSS依赖关系 描述 获取htmlwidgets的JS和CSS依赖关系 用法 getDependency(name, package = name) 参数 name: 控件的名称 package: 包的名称，默认是控件的名称 4.1.4 htmlwidgets-shiny Shiny连接HTML控件 描述 创建在Shiny中使用的output和render函数 用法 shinyWidgetOutput(outputId, name, width, height, package = name, inline = FALSE, reportSize = FALSE) shinyRenderWidget(expr, outputFunction, env, quoted) 参数 outputId: 输出对应的ID name: 控件创建的名称 width,height: 必须是有效的CSS单元(像：“100%”,“400px”,“auto”) 或者是数字 package: 包含控件的包 inline: 对输出使用一个行内的标签(&lt;spqn&gt;) reportSize: 应该在Shiny的会话客户端数据中报告控件的容器大小吗？ expr: 一个产生HTML控件的而表达式 outputFunction: Shiny输出函数，与render函数对应 env: 在什么环境变量下计算expr quoted: expr是引用的表达式（用quote()）吗？这是有用的，如果你想保存 变量中的表达式。 细节 这些功能放在控件内部，为Shiny创建控件和渲染控件所用，详细的可见下面的例子。 值 创建Shiny可用的output和render函数对 例子 # shiny output binding for a widget named &#39;foo&#39; fooOutput &lt;- function(outputId, width = &quot;100%&quot;, height = &quot;400px&quot;) { htmlwidgets::shinyWidgetOutput(outputId, &quot;foo&quot;, width, height) } # shiny render function for a widget named &#39;foo&#39; renderFoo &lt;- function(expr, env = parent.frame(), quoted = FALSE) { if (!quoted) { expr &lt;- substitute(expr) } # force quoted htmlwidgets::shinyRenderWidget(expr, fooOutput, env, quoted = TRUE) } 4.1.5 JS 把R中的字符串转化成合法的JavaScript脚本 描述 JS()函数把接受到的字符向量转化成客户端的JavaScript脚本 用法 JS(...) 参数 …: 一个字符串，字符串的内容就是JavaScript脚本 作者 Yihui Xie 例子 library(htmlwidgets) JS(&#39;1 + 1&#39;) list(x = JS(&#39;function(foo) {return foo;}&#39;), y = 1:10) JS(&#39;function(x) {&#39;, &#39;return x + 1;&#39;, &#39;}&#39;) 4.1.6 onRender 渲染后执行自定义的JavaScript代码 描述 使用这个函数来补充控件内置的JavaScript渲染逻辑 自定义JavaScript代码，只针对这个特定的控件对象。 用法 onRender(x, jsCode, data = NULL) 参数 x: 一个HTML控件 jsCode: JS代码字符串 data: 传给JS的数据，转化为JSON数据 例如 ## Not run: library(leaflet) # This example uses browser geolocation. RStudio users: # this won&#39;t work in the Viewer pane; try popping it # out into your system web browser. leaflet() %&gt;% addTiles() %&gt;% onRender(&quot; function(el, x) { // Navigate the map to the user&#39;s location this.locate({setView: true}); } &quot;) # This example shows how you can make an R data frame available # to your JavaScript code. meh &lt;- &quot;&amp;#x1F610;&quot;; yikes &lt;- &quot;&amp;#x1F628;&quot;; df &lt;- data.frame( lng = quakes$long, lat = quakes$lat, html = ifelse(quakes$mag &lt; 5.5, meh, yikes), stringsAsFactors = FALSE ) leaflet() %&gt;% addTiles() %&gt;% fitBounds(min(df$lng), min(df$lat), max(df$lng), max(df$lat)) %&gt;% onRender(&quot; function(el, x, data) { for (var i = 0; i &lt; data.lng.length; i++) { var icon = L.divIcon({className: &#39;&#39;, html: data.html[i]}); L.marker([data.lat[i], data.lng[i]], {icon: icon}).addTo(this); } } &quot;, data = df) ## End(Not run) 4.1.7 onStaticRenderComplete 静态渲染后执行JavaScript代码 描述 该机制是为运行代码定制控件实例而设计的，这是无法在页面加载时间完成的，因为控件实例还没有被创建。 用法 onStaticRenderComplete(jsCode) 值 创建了一个htmltools包中的tags$script对象 例子 ## Not run: library(leaflet) library(htmltools) library(htmlwidgets) page &lt;- tagList( leaflet() %&gt;% addTiles(), onStaticRenderComplete( &quot;HTMLWidgets.find(&#39;.leaflet&#39;).setZoom(4);&quot; ) ) print(page, browse = TRUE) ## End(Not run) 4.1.8 prependContent 将附加HTML内容添加到控件中 描述 使用这些函数将额外的HTML内容（主要是JavaScript和/或CSS样式）附加到 控件，用于在独立模式下进行渲染（即在R控制台上打印）或在knitr文档中进行渲染。 当在Shiny的控件渲染函数中运行时，这些函数不受支持，并且将 在该上下文中使用警告。允许多个调用，并且稍后的调用不会撤销以前调用的影响。 用法 prependContent(x, ...) appendContent(x, ...) 参数 x: HTML标签对象 …: 有效的标签，文本或者HTML.或者是他们的一个列表 值 输出一个调整了的HTML控件 4.1.9 saveWidget 把控件保存称HTML文件 描述 把控件保存成HTML文件 用法 saveWidget(widget, file, selfcontained = TRUE, libdir = NULL, background = &quot;white&quot;, title = class(widget)[[1]], knitrOptions = list()) 参数 widget: 需要保存的控件 file: 保存的路径 selfcontained: 是否保存成一个自包含的HTML文档 libdir: HTML依赖的包的路径 background: HTML背景色 title: 产生主页的标题 knitrOptions: 一个knitr代码块的选项列表 4.1.10 scaffoldWidget 为HTML控件创建实现脚手架 描述 将一个HTML控件实现的最小代码添加到一个R包中。这个函数必须从要添加小部件的包的根目录中执行。 用法 scaffoldWidget(name, bowerPkg = NULL, edit = interactive()) 参数 name: 控件的名称 bowerPkg: 这个控件基于Bower包的可选名称。如果您指定这个参数然后Bower将被用来自动下载控件。源代码和依赖项，并将它们添加到小部件的YAML中。 edit: 在创建脚手架后，自动打开控件的JavaScript源文件。 4.1.11 setWidgetIdSeed 为控件元素ID设置随机种子 描述 设置用于生成控件元素ID的随机种子。调用这个函数而不是依赖 默认行为确保跨会话的稳定控件ID。 用法 setWidgetIdSeed(seed, kind = NULL, normal.kind = NULL) 参数 seed: 一个值，整数或者为NULL kind: character or NULL normal.kind: character string or NULL. 4.1.12 sizingPolicy 创建一个空间大小调整策略 描述 Define the policy by which HTML widgets will be sized in various containers (e.g. Browser, RStudio Viewer, R Markdown, Shiny). Note that typically widgets can accept the default sizing policy (or override only one or two aspects of it) and get satisfactory sizing behavior via the automatic sizing logic built into the htmlwidgets framework (see the notes below for the most typical exceptions to this). 用法 sizingPolicy(defaultWidth = NULL, defaultHeight = NULL, padding = NULL, viewer.defaultWidth = NULL, viewer.defaultHeight = NULL, viewer.padding = NULL, viewer.fill = TRUE, viewer.suppress = FALSE, viewer.paneHeight = NULL, browser.defaultWidth = NULL, browser.defaultHeight = NULL, browser.padding = NULL, browser.fill = FALSE, browser.external = FALSE, knitr.defaultWidth = NULL, knitr.defaultHeight = NULL, knitr.figure = TRUE) 参数 defaultWidth: The default width used to display the widget. This parameter specifies the defaultwidth for viewing in all contexts (browser, viewer, and knitr) unless it is specifically overridden with e.g. browser.defaultWidth. defaultHeight: The default height used to display the widget. This parameter specifies the default height for viewing in all contexts (browser, viewer, and knitr) unless it is specifically overridden with e.g. browser.defaultHeight padding: Padding around the widget (in pixels). This parameter specifies the padding for viewing in all contexts (browser and viewer) unless it is specifically overriden by e.g. browser.padding. viewer.defaultWidth: The default width used to display the widget within the RStudio Viewer viewer.defaultHeight: The default height used to display the widget within the RStudio Viewer. viewer.padding: Padding around the widget when displayed in the RStudio Viewer (defaults to 15 pixels). viewer.fill: When displayed in the RStudio Viewer, automatically size the widget to the viewer dimensions (note that viewer.padding is still applied). Default to TRUE. viewer.suppress: Never display the widget within the RStudio Viewer (useful for widgets that require a large amount of space for rendering). Defaults to FALSE. viewer.paneHeight: Request that the RStudio Viewer be forced to a specific height when displaying this widget. browser.defaultWidth: The default width used to display the widget within a standalone web browser. browser.defaultHeight: The default height used to display the widget within a standalone web browser. browser.padding: Padding around the widget when displayed in a standalone browser (defaults to 40 pixels). browser.fill: When displayed in a standalone web browser, automatically size the widget tothe browser dimensions (note that browser.padding is still applied). Defaults to FALSE. browser.external: When displaying in a browser, always use an external browser (via browseURL()). Defaults to FALSE, which will result in the use of an internal browser within RStudio v1.1 and higher. knitr.defaultWidth: The default width used to display the widget within documents generated by knitr (e.g. R Markdown). knitr.figure: Apply the default knitr fig.width and fig.height to the widget when it’s rendered within R Markdown documents. Defaults to TRUE. 细节 The default HTML widget sizing policy treats the widget with the same sizing semantics as an R plot. When printed at the R console the widget is displayed within the RStudio Viewer and sized to fill the Viewer pane (modulo any padding). When rendered inside an R Markdown document the widget is sized based on the default size of figures in the document. You might need to change the default behavior if your widget is extremely large. In this case you might specify viewer.suppress = TRUE and knitr.figure = FALSE as well provide for a larger default width and height for knitr. You also might need to change the default behavior if you widget already incorporates padding. Inthis case you might specify viewer.padding = 0. For additional details on widget sizing:vignette(“develop_sizing”, package = “htmlwidgets”) 相关细节可以参考第二章 值 一个控件大小的调整策略 "],
["summary.html", "第 5 章 总结", " 第 5 章 总结 R语言之所以在数据科学领域受到如此的重视，特别是在交互可视化方面要优于Python(虽然Python也有像bokeh,pyecharts,dash等优秀的交互可视化模块)。我认为其主要原因在于R通过htmlwidgets包很好的融合JavaScript，使得R可视化可以尽情的调用漂亮的JavaScript前端可视化的库，像Echarts,D3等等，并且原生的与R Markdown,Shiny结合实现动态的基于Web的系统原型搭建和自动化分析报告展示。 通过htmlwidgets的学习，相信大家应该明白像Leaflet,rbokeh,networkD3,recharts,threejs,DataTables等等这样的优秀的交互可视化和数据展示的R包是如何实现的了，并能基于JavaScript实现自己的交互可视化R包，期待读者基于htmlwidgets的R包的问世。 最后引用Rstudio官网对于htmlwigets包的描述： 把最好的JavaScript数据可视化应用到R 在R控制台上使用JavaScript可视化库，就像绘图一样 在R Markdown文档和Shiny Web应用程序中嵌入控件 使用一个无缝连接R和JavaScript的框架开发新的控件 "],
["reference.html", "第 6 章 参考文献", " 第 6 章 参考文献 [1]. GitHub上htmlwidgets的地址 [2]. CRAN上htmlwidgets的地址 [3]. Rstudio官网上的地址 [4]. 官方说明文档 "]
]
